## 数组

### 理论基础

数组是存放在连续内存空间中的相同类型数据的集合。

需要注意的是：

- 数组下表都是从0开始的。

- 数组内存空间的地址是连续的（二维也是连续的）

  正是因为数组在内存空间中的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。

- 数组的元素不能删除，只能覆盖



### 测试代码

```c++
void test_arr() {
    int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0]<< endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1]<< endl;
}

int main() {
    test_arr();
}
```

```c++
//测试结果
0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
//说明二维数组的地址也是连续的，每两个值之间相差4，是因为这是一个int型的数组，一个int 4字节
```



### 例题

#### 二分查找

##### 问题

给定一个n个元素的整型数组 nums 和一个目标值 target，写一个函数搜索nums中的target，如果目标值存在返回下标，否则返回-1。**（这个数组必须是有序的，否则需要先排序才能在用二分查找的算法）**

##### 思路

这种题目的前提是数组为有序数组，同时强调数组中无重复元素，因为一但有重复的元素，使用二分查找返回的下表不唯一。

写二分法，区间的定义一般分为两种，左闭右闭即 **[left,right]**,或者左闭右开即**[left,right)**.

下面我们用这两种区间的定义分别来讲解两种不同的二分写法

##### 二分法代码(数组按升序的方式排列)

```c++
//左闭右闭 [left,right]
class Solution{
  public:
    int search(vector<int>& nums,int target)
    {
        int left=0;//左指针指向第一个元素
        int right=nums.size()-1;//右指针指向最后一个元素
        while(left<=right)
        {
            int mid=left+((right-left)/2);//防止溢出，等同于(left+right)/2
            if(nums[mid]>target)
                right=mid-1;
           	else if(nums[mid]<target)
                left=mid+1;
            else
                return mid;           
        }
        return -1;//未找到
    }
};
```

```c++
//左闭右开[left,right)
class Solution{
  public:
    int search(vector<int>& nums,int target)
    {
        int left=0;//左指针指向第一个元素
        int right=nums.size()-1;//右指针指向最后一个元素
        while(left<right)//因为left=right在左闭右开的范围内无效，所以不需要等于
        {
            int mid=left+((right-left)/2);//防止溢出，等同于(left+right)/2
            if(nums[mid]>target)
                right=mid-1;
           	else if(nums[mid]<target)
                left=mid+1;
            else
                return mid;           
        }
        return -1;//未找到
    }
};
```

##### 例题

- [二分查找](https://leetcode-cn.com/problems/binary-search/)
- [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

- [二分查找确定左右边界](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

**以“在排序数组中查找元素的第一个和最后一个位置”为例**

**题目：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。**

**如果数组中不存在目标值 target，返回 [-1, -1]。**

**分析：寻找target在数组里的左右边界，共有如下三种情况**

1. **target在数组范围的右边或者左边（即大于数组的最大值或者小于数组的最小值），例如nums={3，4，5}，target=6，此时返回{-1，-1}；**
2. **target在数组范围中，但数组中不存在target，例如nums={3，6，7}，target=5，此时应该返回{-1，-1}；**
3. **target在数组范围中，且数组中存在target，例如nums={3，6，7}，target={6}，此时应该返回{1，1}**

**据此我们就可写出如下代码，分别找出左右边界。**

```c++
//题解
/*for循环遍历数组，k用来记录共出现几次，result用来记录出现的位置
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result;
        int k=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==target)
            {
            result.push_back(i);
            k++;
            }
        }
        if(k==0)
        return {-1,-1};
        else
        return {result[0],result[k-1]};
    }
};*/


//利用二分查找分别搜索左右边界
class Solution {
public:
    int FindLeftBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int leftborder=-2;//边界的初始值不能赋值为-1，若数组的第一个元素为目标值，则左边界为-1，有边界同理
        while(left<=right)
        {
            int mid=left+((right-left)/2);
            if(nums[mid]>=target)//不停的缩小左边界
            {
                right=mid-1;
                leftborder=right;
            }
            else
            left=mid+1;
        }
        return leftborder;
    }

    int FindRightBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int rightborder=-2;
        while(left<=right){
        int mid=left+((right-left)/2);
        if(nums[mid]<=target)//不停的缩小右边界
        {
            left=mid+1;
            rightborder=left;
        }
        else
        right=mid-1;
        }
        return rightborder;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftborder;
        int rightborder;
        
        leftborder = FindLeftBorder(nums,target);
        rightborder = FindRightBorder(nums,target);
        
        /*左边界与右边界等于-2证明目标值不在数组范围内*/
        if(leftborder==-2)
        return {-1,-1};
        
        /*因为左边界指向最左边的目标值的前一个位置，有边界指向最右边的目标值的下一个位置，因此需要大于1不能有等于1*/
        else if((rightborder-leftborder)>1)
        return {leftborder+1,rightborder-1};
        
        /*所要查找的元素位于数组范围中但并不再数组中，这样左边界与有边界就会相邻，相减等于1*/
        /*nums = [5,7,7,8,8,10]，target = 6*/
        else
        return {-1,-1};
    }
};
```



#### 移除元素

题目：[移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

##### 解法

**暴力解法**

两层for循环，一个for循环遍历数组元素，第二个for循环更新数组

```c++
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
```

**双指针法**

通过一个快指针和慢指针在一个for循环下完成两个for循环的工作

```c++
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

#### 有序数组的平方

[力扣题目链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

**题目：给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序**

##### 暴力排序：平方后排序

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        for (int i = 0; i < A.size(); i++) {
            A[i] *= A[i];
        }
        sort(A.begin(), A.end()); // 快速排序
        return A;
    }
};
```

##### 双指针法

**数组本身是有序的，只不过负数的平方可能比正数的平方大，那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。**

**此时就可以考虑双指针法了，i指向起始位置，j指向终止位置。**

**定义一个新数组result，和原数组一样大小，让k指向result数组终止位置。**

**如果A[i] * A[i] < A[j] * A[j]那么result[k--]=A[j] * A[j]**

**如果A[i] * A[i] >=A[j] * A[j]那么result[k--]=A[i] * A[i]**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

#### 长度最小的子数组

题目：[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

##### 题解

**暴力解法**

两个for循环遍历数组，不断的寻找符合条件的子序列，时间复杂度为O(n^2)

```c++
class Solutin{
    public:
    int minSubArrayLen(int s,vector<int>& nums)
    {
        int result=INT32_MAX;//最终结果
        int sum=0;
        int subLength=0;
        for(int i=0;i<nums.size();i++)
        {
            sum=0;
            for(int j=i;j<nums.size();j++)
            {
                sum=sum+nums[j];
                if(sum>=s){
                    subLength=j-i+1;//更新长度
                    result=result<subLength?result:subLength;//更新result，因为需要找的是符合条件的最短的串
                    break;//找到了以i为起点以j为终点的最短的串，退出当前循环
                }
            }
        }
    }
}
```

##### 滑动窗口

不断的调节子序列的起始位置和终止位置，从而得出我们想要的结果

**在本题中实现滑动窗口，主要确定如下三点：**

- 窗口内是什么？

  窗口就是满足其和大于等于目标值的长度最小的连续子数组。
  
- 如何移动窗口的起始位置？

  窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）

- 如何移动窗口的结束位置？

  窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i=0,j=0;
        int result=INT32_MAX;
        int mid=0;
        int len;
        while(j<nums.size())
        {
            mid=mid+nums[j];
            while(mid>=target)
            {
                len=j-i+1;//计算当前的长度
                result=result<len?result:len;//更新长度，将较短的填入result
                mid=mid-nums[i++];//移动窗口的起始位置，将当前起始位置的值减掉，将起始位置向后移动一个
            }
            j++;//调整窗口的结束位置
        }
        /*for(int j=0;j<nums.size();j++)//j表示终点，
        {
        mid=mid+nums[j];
        while(mid>=target){
            len=j-i+1;
            result=result<len?result:len;
            mid=mid-nums[i];
            i++;
        }
        }*/
        return result=(result==INT32_MAX)?0:result;
    }
};
```



#### 螺旋矩阵Ⅱ

题目：[螺旋矩阵Ⅱ](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 

##### 题解

**本题在面试中出现频率较高，并且本体并不涉及算法，就是模拟过程，但却十分考察对代码的掌控能力。**

模拟顺时针画矩阵的过程：

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

```c++
class Solution{
  public:
    vector<vector<int>> generateMatrix(int n){
        vector<vector<int>> res(n,vector<int>(n,0));//定义一个二维数组
        int startx=0,starty=0;//定义每循环一个圈的起始位置
        int loop=n/2;//每个圈循环几次
        int mid=n/2;//矩阵中间的位置
        int count=1；//用来给矩阵中每一个空格赋值
        int offset=1;//每一圈循环，需要控制每一条边遍历的长度
        int i,j;
        while(loop--){
            i=startx;
            j=starty;
            
            //填充上行从左到右
            for(j=starty;j<starty+n-offset;j++)
            	res[startx][j]=count++;
            //填充右列从上到下
            for(i=startx;i<startx+n-offset;i++)
                res[i][j]=count++;
            //填充下行从右到左
            for(;j>starty;j--)
                res[i][j]=count++;
            //填充左列从下到上
            for(;i>startx;i--)
                res[i][j]=count++;
            
            startx++;
            starty++;
            
            offset+=2;
        }
        if(n%2){
            res[mid][mid]=count;
        }
        return res;
    }
};
```

```c++
class Solution{
  public:
    vector<vector<int>> generateMatrix(int n){
        vector<vector<int>> res(n,vector<int>(n,0));//定义一个二维数组
        int tot=0;
        int x=0,y=0;
        tot=res[x][y]=1;//因为第一个位置肯定是1，所以先赋值，方便后面的循环判断，防止有bug陷入死循环。
        while(tot<n*n)
        {
            //判断下一个位置是否为0，若判断当前位置是否为0会陷入死循环
            //上行从左往右，左闭右开
            while(y+1<n&&!res[x][y+1]) res[x][++y]=++tot;
            
            //右列从上往下，上闭下开
            while(x+1<n&&!res[x+1][y]) res[++x][y]=++tot;
            
            //下行从右往左，左开右闭
            while(y-1>=0&&!res[x][y-1]) res[x][--y]=++tot;
            
            //左列从下往上，上开下闭
            while(x-1>=0&&!res[x-1][y]) res[--x][y]=++tot;
            
            /*错误写法*/
            /*没有给起始位置赋初值1*/
            /*下面的写法在写完一圈后x会回到第一个位置，而这个位置已经赋值了，因此就会陷入死循环
          /*while (y < n-1 && !res[x][y]) res[x][y++] = ++tot;
			while (x < n-1 && !res[x][y]) res[x++][y] = ++tot;
			while (y > 0 && !res[x][y]) res[x][y--] = ++tot;
			while (x > 0 && !res[x][y]) res[x--][y] = ++tot;*/
        }
        return res;
    }
};
```



## 链表

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放下一个节点的指针），最后一个节点的指针域指向null。

链接的入口节点称为链表的头结点也就是head。

### 链表的类型

#### 单链表

#### 双链表

每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表既可以向前查询也可以向后查询

#### 循环链表

首位相连，循环链表可以解决约瑟夫环问题。

### 链表的存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

### 链表的实现

#### 链表的定义

##### 代码

```c++
//单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
//若不定义构造函数，c++会生成一个默认的构造函数

//通过自己定义构造函数初始化节点
ListNode* head = new ListNode(5);

//使用默认构造函数初始化节点
ListNode* head = new ListNode();
head->val = 5;
//如果不定义构造函数使用默认的构造函数的话，在初始化的时候就不能直接给变量赋值
```

#### 链表的操作

##### 删除节点



![链表-删除节点](https://img-blog.csdnimg.cn/20200806195114541.png)

D节点依然存留在内存中，如果是C++语言的话需要手动释放这块内存，其他语言例如Java，Python，有自己的内存回收机制，就不需要手动释放了。

##### 添加节点

![链表-添加节点](https://img-blog.csdnimg.cn/20200806195134331.png)

可以看出链表的增添和删除都是O(1)时间复杂度，也不会影响其他节点，但要注意，要删除第五个节点需要从头查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)

### 性能分析

数组插入慢O(n)，查找快O(1)。 适用场景：数据量固定，频繁查询，较少增删。

链表插入快O(1)，查找慢O(n)。 适用场景：数据量不固定，频繁增删，较少查询。

数组在定义时，长度是固定的，如果想改动数组的长度，就需要定义一个新的数组。

链表的长度是不固定的，并且可以动态增删，适合数据量不固定，频繁增删，较少查询的场景。

### 例题

#### 移除链表的元素

题目：[移除链表的元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

删除链表中等于给定值val的所有节点。

##### 题解

**不设置哑元删除节点**

```c++
class Solution{
  public:
    ListNode* removeElements(ListNode* head,int val){
        /*不使用哑元删除头结点属于特殊情况，需要单独考虑*/
        while(head!=nullptr&&head->val==val)
        {
            ListNode* tmp = head;
            head=head->next;
            delete tmp;
        }
        
        /*删除非头结点*/
        ListNode *cur = head;
        while(cur!=nullptr&&cur->next!=nullptr){//可能这个链表本身就是空的，因此需要判断当前节点是否为空以及当前节点的下一个节点是否为空
            if(cur->next->val==val)
            {
                ListNode* tmp = cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }
            else
                cur=cur->next;
        }
        return head;
    }
};
```

**设置哑节点**

```c++
class Solution{
  public:
    ListNode* removeElements(ListNode* head,int val){
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next=head;
        ListNode* cur = dummyHead;
        while(cur->next!=nullptr)
        {
            if(cur->next->val==val)
            {
                ListNode* tmp = cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }
            else
                cur=cur->next;
        }
        return dummyHead->next;
    }
};
```



#### 设计链表

题目：[设计链表实现要求的功能](https://leetcode-cn.com/problems/design-linked-list/)

- get(index): 获取链表中第index个节点的值。如果索引无效则返回-1.
- addAtHead(val): 在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将称为链表的第一个节点。
- addAtTail(val): 将值为val的节点追加到链表的最后一个元素。
- addAtIndex(index,val): 在链表中的第index个节点之前添加值为val的节点。如果index等于链表的长度，则该节点将符加到链表的末尾。如果index大于链表的长度，则不会插入节点。如果index小于0，则插在头部
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

##### 题解:

使用哑元

```c++
class MyLinkedList{
  public:
    struct LinkedNode{
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val),next(nullptr){}
    };
    //初始化链表
    MyLinkedList(){
        dummyHead = new LinkedNode(0);
        size = 0;
    }
    /*获取到第index个节点的值，如果index非法返回-1，index是从0开始*/
    int get(int index){
        if(index>=size||index<0)
            return -1;
        LinkedNode* cur = dummyHead->next;
        while(index--)
            cur=cur->next;
        return cur->val;
    }
    /*在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点*/
    void addAtHead(int val){
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next=dummyHead->next;
        dummyHead->next = newNode;
        size++;
    }
    
    /*在链表最后面添加一个节点*/
    void addAtTail(int val){
        LinkedNode* cur = dummyHead;
        while(cur->next!=nullptr)//找到链表最后一个元素，返回它的指针
            cur=cur->next;
        LinkedNode* newNode = new LinkedNode(val);
        cur->next=newNode;
        size++;
    }
    
    /* 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。*/
    /* 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点*/
    /* 如果index大于链表的长度，则返回空*/
    void addAtIndex(int index,int val){
        if(index>size)
            return;
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = dummyHead;
        while(index--)
            cur=cur->next;
        newNode->next = cur->next;
        cur->next = newNode;
        size++;
    }
    
    /*删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的*/
    void deleteAtIndex(int index){
        if(index>=size||index<0)
            return;
        LinkedNode* cur = dummyHead;
        while(index--){
            cur=cur->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        size--;
    }
    private:
    int size;
    LinkedNode* dummyHead;
};
```



#### 反转链表

题目：[反转一个单链表](https://leetcode-cn.com/problems/reverse-linked-list/)

##### 题解

![206_反转链表](https://img-blog.csdnimg.cn/20210218090901207.png)

**使用两个指针**

![img](https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

首先定义一个cur指针，指向头结点，在定义一个pre指针，初始化null。

然后开始反转，首先cur->next节点用tmp指针保存一下，也就是保存一下这个节点，为什么要保存一下这个节点呢，因为接下来要改变cur->next的指向了，将cur->next指向pre，此时已经反转了第一个节点了。接下来就是循环执行。最后cur指针已经指向null，循环结束，链表也反转完毕了，此时我们return pre指针就可以了

##### 代码

```c++
/*双指针法*/
class Soultion{
  public:
    ListNode* reverseList(ListNode* head){
    	ListNode* temp;//保存cur的下一个节点
    	ListNode* cur = head;
    	ListNode* pre = nullptr;
        while(cur){
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};

/*递归法*/
class Solution{
  public:
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur==nullptr) return pre;
        ListNode* temp = cur->next;
        cur->next = pre;
        return reverse(cur,temp);
    }
    
    ListNode* reverseList(ListNode* head){
        return reverse(nullptr,head);
    }
};
```

**我们发现上面的递归写法和双指针写法实质上都是从前往后翻转指针指向其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向**

```c++
class Solution{
    public:
    ListNode* reverseList(ListNode* head){
        if(head == nullptr) return nullptr;
        if(head->next==nullptr) return head;
        
        ListNode *last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```



#### 两两交换链表中的节点

题目：[给定一个链表，两两交换其中相邻的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

##### 题解

对交换过程正常进行模拟就可以，设置虚节点，不然每次针对头结点还要单独处理；

![24.两两交换链表中的节点1](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

##### 代码

```c++
class Solution{//从需要交换值的两个节点的前一个结点开始
  public:
    ListNode* swapPairs(ListNode* head)
    {
        ListNode* dummyHead = new ListNode(0);//设置哑节点
        dummyHead->next = head;
        ListNode* cur = dummyHead;//设置指针并指向哑节点，每次交换完成后将指针移动两下
        while(cur->next!=nullptr&& cur->next->next!=nullptr)
        {
           /* ListNode* tmp = cur->next;
            ListNode* tmp! = cur->next->next->next;
            cur->next = cur->next->next;
            cur->next->next = tmp;
            cur->next->next->next = tmp1;*/
            
            ListNode* tmp = cur->next;//保存需要交换的前一个结点
            cur->next = cur->next->next;//将两个结点之前的结点指向需要交换的第二个结点
            tmp->next = cur->next->next;//将需要交换的第一个结点指向第二个结点的下一个结点
            cur->next->next = tmp;//将第二个结点的下一个结点指向第一个结点
            
            cur = cur->next->next//将指针移动两下，指针后的两个结点为需要进行交换的结点。
        }
        return dummyHead->next;
    }
};
```



#### 删除链表中倒数第n个节点

题目：[删除链表的倒数第n个节点，返回头节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

进阶：能否使用一趟扫描实现

##### 题解

- 第一种可对链表进行两次扫描，第一次扫描得出链表得长度，从而通过计算得出倒数第n个是正数第几个，从而进行第二次扫描删除结点
- 使用双指针，第一个指针先走n步，之后两个指针一块走，当第一个指针走到最后一个元素得时候，第二个指针就指向了需要删除的结点得上一个结点。从而进行删除。

##### 代码

```c++
class Solution{//两次扫描，不适用哑节点
    public:
    ListNode* removeNthFromEnd(ListNode* head,int n)
    {
        int nums=0;//记录链表共有多少个节点
        ListNode* cur = head;
        while(cur!=nullptr)
        {
            nums++;
            cur = cur->next;
        }
        ListNode* tmp = head;
        if(n==nums)//需要删除的是头结点，因头结点前面没有节点，所以需要单独处理
        {
            head = head->next;
            return head;
        }
        for(int i=0;i<nums-n-1;i++)
        {
            tmp = tmp->next;
        }
        tmp->next = tmp->next->next;
        return tmp;
    }
    
};
```

```c++
class Solution{//使用双指针，第一个指针先走n步，之后两个指针一块走，当第一个指针走到最后一个节点时，第二个指针就指向了需要删除的节点得上一个节点
  public:
    ListNode* removeNthFromEnd(ListNode* head,int n)
    {
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;
        ListNode* fast = dummyHead;
        ListNode* slow = dummyHead;
        for(int i=0;i<n&&;i++)
            fast = fat->next;
        while(fast->next!=nullptr)
        {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyHead->next;
    }
};
```





#### 链表相交

题目：[链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点，如果两个链表没有相交，返回null。

##### 题解

简单来说就是求两个链表交点节点的指针。**需要注意交点不是数值相等，而是指针相等**

我们先遍历两个链表，求出两个链表的长度两个链表的长度做差得出一个值，让长的链表先移动一定的值使指向两个链表的指针在同一位置，之后一次移动两个链表的指针，直到结束，如果有指针相等，则此节点为相交的节点，否则没有相交

##### 代码

```c++
class Solution{
  ListNode* getIntersectionNode(ListNode* headA,ListNode* headB)  
  {
      int numA=0;
        int numB=0;
        int len;
        ListNode* curA = headA;
        ListNode* curB = headB;
        /*统计两个链表的长度*/
        while(curA!=nullptr)
        {
            curA = curA->next;
            numA++;
        }
        while(curB!=nullptr)
        {
            curB=curB->next;
            numB++;
        }

        curA = headA;
        curB = headB;
    /*调整指向链表的指针*/
        if(numA>numB)//a链表长
        {
        len = numA-numB;
        for(int i = 0;i<len;i++)
        curA = curA->next;
        while(curA!=nullptr)
        {
            if(curA==curB)
            return curA;
            curA=curA->next;
            curB=curB->next;
        }
        }

        else//b链表长
        {
        len = numB-numA;
        for(int i = 0;i<len;i++)
        curB = curB->next;
        while(curA!=nullptr)
        {
            if(curA==curB)
            return curA;
            curA=curA->next;
            curB=curB->next;
        }
        }
        return nullptr;
  }
};
```



#### 环形链表Ⅱ

题目：[环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null

说明：不允许修改给定的链表

##### 题解

1.判断是否有环

使用快慢指针法，快指针每次走两步，慢指针每次走一步，如果两个指针相遇，则证明有环

2.求出环的其实位置

假设从头节点到环形入口的节点数为x。环形入口节点到fast指针与slow指针相遇的节点的节点数为y，从相遇节点到环形入口节点的节点数为z。

![142环形链表2](https://img-blog.csdnimg.cn/20210318162938397.png)

快指针走的节点数始终是慢指针的两倍，根据这个等式可列出方程解出x的值

慢指针走的节点：x+y

快指针走的节点：x+n*(y+z)+y

2x+2y = x+n(y+z)+y

x = ny+nz-y   ----> x = (n-1)(y+z) + z  n为快指针在环中走的圈数

**该表达式表明了从相交节点绕环走n-1圈在刚好走一个z的距离和x相等，走n-1圈又回到相交节点，在走z个节点刚还到达环的入口，若让一个指针指向头结点，并和相交节点的指针一块移动，则此时它们会在环的入口相遇**

由次式可看出头结点指针与相交节点的指针同时走，当他们相交时，便是环的入口

##### 代码

```c++
class Solution{
  public:
    ListNode* detectCycle(ListNode* head){
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=nullptr&&fast->next!=nullptr)
        {
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow)
            {
                ListNode* cur = head;
                while(cur!=fast)
                {
                    fast = fast->next;
                    cur = cur->next;
                }
                return cur;
            }
        }
        return nullptr;
    }
};
```





## 回溯算法

一般回溯算法都涉及递归，是一种暴力的搜索方法。for循环横向遍历，递归纵向遍历（树形结构）

### 解决的问题

**1.组合问题(没有顺序)**

[组合总和(无重复元素的整数数组)](https://leetcode-cn.com/problems/combination-sum/)

[组合总和2(需要处理掉重复的结果)](https://leetcode-cn.com/problems/combination-sum-ii/)

**2.切割问题**

[一个字符串进行切割并返回所有的组成的回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

[复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

**3.子集问题**

求一个集合的子集。

**4.排列问题(有顺序)**

与组合问题相对应

**5.棋盘问题**

n皇后问题等等，（还没遇到）

### 模板

```c++
void backtracking(参数)
{
    if(终止条件){
        收集结果;
        return;
    }
    
    for(集合元素){
        处理节点;
        递归函数;
        回溯函数;（类似于栈，将之前的中间值出栈，撤销处理结果，尝试其他的可能性）
    }
}
```



## 字符串的模式匹配

给定两个字符串S和T，**在主串S中寻找字串T的过程称为模式匹配**，**T称为模式**。如果匹配成功，则返回T在S中的位置；如果匹配失败，返回0.

### BF算法（朴素的模式匹配算法）

#### 概念

BF算法是一种**回溯**的匹配算法，其基本思想是：从主串S的第一个字符开始和模式T的第一个字符进行比较，若相等，则继续比较二者后续的字符，否则，则从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直到S或T中的所有字符比较完毕。若T中的所有字符全部比较完成，则匹配成功，否则匹配失败。

#### 代码

```c++
int BF(string a,string b)
{
    int i=0,j=0;
    while(i<a.size()&&j<b.size())
    {
        if(a[i]==b[j])
        {
            i++;
            j++;
        }
        else
        {
            i=i-j+1;//返回主串中上一次开始匹配的下一个位置
            j=0;//重新从字串的第一个位置开始匹配
        }
    }
    if(j==b.size())//若字串全部匹配完成，则匹配成功
        return i-j+1;//返回字串所在主串中的位置，不是数组下标
    else
        return -1;
}
```

#### 时间复杂度

**最好的情况：每次不成功的匹配都发生在模式T的第一个字符   O(m+n)**

**最坏的情况：每次匹配不成功都发生在模式T的最后一个字符   O(n*m)**

### KMP算法(BF算法的改进)

#### 概念

BF算法简单但效率低，一种对BF算法做了很大改进的模式匹配算法是KMP算法，其基本思想是主串不进行回溯。

**希望在某趟S[i]和T[j]匹配失败后，下标i不回溯，下标j回溯至某个位置k，使得T[k]对准S[j]继续比较。显然关键问题是如何确定k。**

#### 代码





### rabin karp算法（基于Hash的字符串匹配）

例题：[最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

