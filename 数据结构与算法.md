## 数组

### 理论基础

数组是存放在连续内存空间中的相同类型数据的集合。

需要注意的是：

- 数组下表都是从0开始的。

- 数组内存空间的地址是连续的（二维也是连续的）

  正是因为数组在内存空间中的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。

- 数组的元素不能删除，只能覆盖



### 测试代码

```c++
void test_arr() {
    int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0]<< endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1]<< endl;
}

int main() {
    test_arr();
}
```

```c++
//测试结果
0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
//说明二维数组的地址也是连续的，每两个值之间相差4，是因为这是一个int型的数组，一个int 4字节
```



### 例题

#### 二分查找

##### 问题

给定一个n个元素的整型数组 nums 和一个目标值 target，写一个函数搜索nums中的target，如果目标值存在返回下标，否则返回-1。**（这个数组必须是有序的，否则需要先排序才能在用二分查找的算法）**

##### 思路

这种题目的前提是数组为有序数组，同时强调数组中无重复元素，因为一但有重复的元素，使用二分查找返回的下表不唯一。

写二分法，区间的定义一般分为两种，左闭右闭即 **[left,right]**,或者左闭右开即**[left,right)**.

下面我们用这两种区间的定义分别来讲解两种不同的二分写法

##### 二分法代码(数组按升序的方式排列)

```c++
//左闭右闭 [left,right]
class Solution{
  public:
    int search(vector<int>& nums,int target)
    {
        int left=0;//左指针指向第一个元素
        int right=nums.size()-1;//右指针指向最后一个元素
        while(left<=right)
        {
            int mid=left+((right-left)/2);//防止溢出，等同于(left+right)/2
            if(nums[mid]>target)
                right=mid-1;
           	else if(nums[mid]<target)
                left=mid+1;
            else
                return mid;           
        }
        return -1;//未找到
    }
};
```

```c++
//左闭右开[left,right)
class Solution{
  public:
    int search(vector<int>& nums,int target)
    {
        int left=0;//左指针指向第一个元素
        int right=nums.size()-1;//右指针指向最后一个元素
        while(left<right)//因为left=right在左闭右开的范围内无效，所以不需要等于
        {
            int mid=left+((right-left)/2);//防止溢出，等同于(left+right)/2
            if(nums[mid]>target)
                right=mid-1;
           	else if(nums[mid]<target)
                left=mid+1;
            else
                return mid;           
        }
        return -1;//未找到
    }
};
```

##### 例题

- [二分查找](https://leetcode-cn.com/problems/binary-search/)
- [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

- [二分查找确定左右边界](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

**以“在排序数组中查找元素的第一个和最后一个位置”为例**

**题目：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。**

**如果数组中不存在目标值 target，返回 [-1, -1]。**

**分析：寻找target在数组里的左右边界，共有如下三种情况**

1. **target在数组范围的右边或者左边（即大于数组的最大值或者小于数组的最小值），例如nums={3，4，5}，target=6，此时返回{-1，-1}；**
2. **target在数组范围中，但数组中不存在target，例如nums={3，6，7}，target=5，此时应该返回{-1，-1}；**
3. **target在数组范围中，且数组中存在target，例如nums={3，6，7}，target={6}，此时应该返回{1，1}**

**据此我们就可写出如下代码，分别找出左右边界。**

```c++
//题解
/*for循环遍历数组，k用来记录共出现几次，result用来记录出现的位置
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result;
        int k=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==target)
            {
            result.push_back(i);
            k++;
            }
        }
        if(k==0)
        return {-1,-1};
        else
        return {result[0],result[k-1]};
    }
};*/


//利用二分查找分别搜索左右边界
class Solution {
public:
    int FindLeftBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int leftborder=-2;//边界的初始值不能赋值为-1，若数组的第一个元素为目标值，则左边界为-1，有边界同理
        while(left<=right)
        {
            int mid=left+((right-left)/2);
            if(nums[mid]>=target)//不停的缩小左边界
            {
                right=mid-1;
                leftborder=right;
            }
            else
            left=mid+1;
        }
        return leftborder;
    }

    int FindRightBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int rightborder=-2;
        while(left<=right){
        int mid=left+((right-left)/2);
        if(nums[mid]<=target)//不停的缩小右边界
        {
            left=mid+1;
            rightborder=left;
        }
        else
        right=mid-1;
        }
        return rightborder;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftborder;
        int rightborder;
        
        leftborder = FindLeftBorder(nums,target);
        rightborder = FindRightBorder(nums,target);
        
        /*左边界与右边界等于-2证明目标值不在数组范围内*/
        if(leftborder==-2)
        return {-1,-1};
        
        /*因为左边界指向最左边的目标值的前一个位置，有边界指向最右边的目标值的下一个位置，因此需要大于1不能有等于1*/
        else if((rightborder-leftborder)>1)
        return {leftborder+1,rightborder-1};
        
        /*所要查找的元素位于数组范围中但并不再数组中，这样左边界与有边界就会相邻，相减等于1*/
        /*nums = [5,7,7,8,8,10]，target = 6*/
        else
        return {-1,-1};
    }
};
```



#### 移除元素

题目：[移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

##### 解法

**暴力解法**

两层for循环，一个for循环遍历数组元素，第二个for循环更新数组

```c++
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
```

**双指针法**

通过一个快指针和慢指针在一个for循环下完成两个for循环的工作

```c++
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

#### 有序数组的平方

[力扣题目链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

**题目：给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序**

##### 暴力排序：平方后排序

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        for (int i = 0; i < A.size(); i++) {
            A[i] *= A[i];
        }
        sort(A.begin(), A.end()); // 快速排序
        return A;
    }
};
```

##### 双指针法

**数组本身是有序的，只不过负数的平方可能比正数的平方大，那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。**

**此时就可以考虑双指针法了，i指向起始位置，j指向终止位置。**

**定义一个新数组result，和原数组一样大小，让k指向result数组终止位置。**

**如果A[i] * A[i] < A[j] * A[j]那么result[k--]=A[j] * A[j]**

**如果A[i] * A[i] >=A[j] * A[j]那么result[k--]=A[i] * A[i]**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

#### 长度最小的子数组

题目：[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

##### 题解

**暴力解法**

两个for循环遍历数组，不断的寻找符合条件的子序列，时间复杂度为O(n^2)

```c++
class Solutin{
    public:
    int minSubArrayLen(int s,vector<int>& nums)
    {
        int result=INT32_MAX;//最终结果
        int sum=0;
        int subLength=0;
        for(int i=0;i<nums.size();i++)
        {
            sum=0;
            for(int j=i;j<nums.size();j++)
            {
                sum=sum+nums[j];
                if(sum>=s){
                    subLength=j-i+1;//更新长度
                    result=result<subLength?result:subLength;//更新result，因为需要找的是符合条件的最短的串
                    break;//找到了以i为起点以j为终点的最短的串，退出当前循环
                }
            }
        }
    }
}
```

##### 滑动窗口

不断的调节子序列的起始位置和终止位置，从而得出我们想要的结果

**在本题中实现滑动窗口，主要确定如下三点：**

- 窗口内是什么？

  窗口就是满足其和大于等于目标值的长度最小的连续子数组。
  
- 如何移动窗口的起始位置？

  窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）

- 如何移动窗口的结束位置？

  窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i=0,j=0;
        int result=INT32_MAX;
        int mid=0;
        int len;
        while(j<nums.size())
        {
            mid=mid+nums[j];
            while(mid>=target)
            {
                len=j-i+1;//计算当前的长度
                result=result<len?result:len;//更新长度，将较短的填入result
                mid=mid-nums[i++];//移动窗口的起始位置，将当前起始位置的值减掉，将起始位置向后移动一个
            }
            j++;//调整窗口的结束位置
        }
        /*for(int j=0;j<nums.size();j++)//j表示终点，
        {
        mid=mid+nums[j];
        while(mid>=target){
            len=j-i+1;
            result=result<len?result:len;
            mid=mid-nums[i];
            i++;
        }
        }*/
        return result=(result==INT32_MAX)?0:result;
    }
};
```



#### 螺旋矩阵Ⅱ

题目：[螺旋矩阵Ⅱ](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 

##### 题解

**本题在面试中出现频率较高，并且本体并不涉及算法，就是模拟过程，但却十分考察对代码的掌控能力。**

模拟顺时针画矩阵的过程：

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

```c++
class Solution{
  public:
    vector<vector<int>> generateMatrix(int n){
        vector<vector<int>> res(n,vector<int>(n,0));//定义一个二维数组
        int startx=0,starty=0;//定义每循环一个圈的起始位置
        int loop=n/2;//每个圈循环几次
        int mid=n/2;//矩阵中间的位置
        int count=1；//用来给矩阵中每一个空格赋值
        int offset=1;//每一圈循环，需要控制每一条边遍历的长度
        int i,j;
        while(loop--){
            i=startx;
            j=starty;
            
            //填充上行从左到右
            for(j=starty;j<starty+n-offset;j++)
            	res[startx][j]=count++;
            //填充右列从上到下
            for(i=startx;i<startx+n-offset;i++)
                res[i][j]=count++;
            //填充下行从右到左
            for(;j>starty;j--)
                res[i][j]=count++;
            //填充左列从下到上
            for(;i>startx;i--)
                res[i][j]=count++;
            
            startx++;
            starty++;
            
            offset+=2;
        }
        if(n%2){
            res[mid][mid]=count;
        }
        return res;
    }
};
```

```c++
class Solution{
  public:
    vector<vector<int>> generateMatrix(int n){
        vector<vector<int>> res(n,vector<int>(n,0));//定义一个二维数组
        int tot=0;
        int x=0,y=0;
        tot=res[x][y]=1;//因为第一个位置肯定是1，所以先赋值，方便后面的循环判断，防止有bug陷入死循环。
        while(tot<n*n)
        {
            //判断下一个位置是否为0，若判断当前位置是否为0会陷入死循环
            //上行从左往右，左闭右开
            while(y+1<n&&!res[x][y+1]) res[x][++y]=++tot;
            
            //右列从上往下，上闭下开
            while(x+1<n&&!res[x+1][y]) res[++x][y]=++tot;
            
            //下行从右往左，左开右闭
            while(y-1>=0&&!res[x][y-1]) res[x][--y]=++tot;
            
            //左列从下往上，上开下闭
            while(x-1>=0&&!res[x-1][y]) res[--x][y]=++tot;
            
            /*错误写法*/
            /*没有给起始位置赋初值1*/
            /*下面的写法在写完一圈后x会回到第一个位置，而这个位置已经赋值了，因此就会陷入死循环
          /*while (y < n-1 && !res[x][y]) res[x][y++] = ++tot;
			while (x < n-1 && !res[x][y]) res[x++][y] = ++tot;
			while (y > 0 && !res[x][y]) res[x][y--] = ++tot;
			while (x > 0 && !res[x][y]) res[x--][y] = ++tot;*/
        }
        return res;
    }
};
```



## 链表

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放下一个节点的指针），最后一个节点的指针域指向null。

链接的入口节点称为链表的头结点也就是head。

### 链表的类型

#### 单链表

#### 双链表

每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表既可以向前查询也可以向后查询

#### 循环链表

首位相连，循环链表可以解决约瑟夫环问题。

### 链表的存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

### 链表的实现

#### 链表的定义

##### 代码

```c++
//单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
//若不定义构造函数，c++会生成一个默认的构造函数

//通过自己定义构造函数初始化节点
ListNode* head = new ListNode(5);

//使用默认构造函数初始化节点
ListNode* head = new ListNode();
head->val = 5;
//如果不定义构造函数使用默认的构造函数的话，在初始化的时候就不能直接给变量赋值
```

#### 链表的操作

##### 删除节点



![链表-删除节点](https://img-blog.csdnimg.cn/20200806195114541.png)

D节点依然存留在内存中，如果是C++语言的话需要手动释放这块内存，其他语言例如Java，Python，有自己的内存回收机制，就不需要手动释放了。

##### 添加节点

![链表-添加节点](https://img-blog.csdnimg.cn/20200806195134331.png)

可以看出链表的增添和删除都是O(1)时间复杂度，也不会影响其他节点，但要注意，要删除第五个节点需要从头查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)

### 性能分析

数组插入慢O(n)，查找快O(1)。 适用场景：数据量固定，频繁查询，较少增删。

链表插入快O(1)，查找慢O(n)。 适用场景：数据量不固定，频繁增删，较少查询。

数组在定义时，长度是固定的，如果想改动数组的长度，就需要定义一个新的数组。

链表的长度是不固定的，并且可以动态增删，适合数据量不固定，频繁增删，较少查询的场景。

### 例题

#### 移除链表的元素

题目：[移除链表的元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

删除链表中等于给定值val的所有节点。

##### 题解

**不设置哑元删除节点**

```c++
class Solution{
  public:
    ListNode* removeElements(ListNode* head,int val){
        /*不使用哑元删除头结点属于特殊情况，需要单独考虑*/
        while(head!=nullptr&&head->val==val)
        {
            ListNode* tmp = head;
            head=head->next;
            delete tmp;
        }
        
        /*删除非头结点*/
        ListNode *cur = head;
        while(cur!=nullptr&&cur->next!=nullptr){//可能这个链表本身就是空的，因此需要判断当前节点是否为空以及当前节点的下一个节点是否为空
            if(cur->next->val==val)
            {
                ListNode* tmp = cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }
            else
                cur=cur->next;
        }
        return head;
    }
};
```

**设置哑节点**

```c++
class Solution{
  public:
    ListNode* removeElements(ListNode* head,int val){
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next=head;
        ListNode* cur = dummyHead;
        while(cur->next!=nullptr)
        {
            if(cur->next->val==val)
            {
                ListNode* tmp = cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }
            else
                cur=cur->next;
        }
        return dummyHead->next;
    }
};
```



#### 设计链表

题目：[设计链表实现要求的功能](https://leetcode-cn.com/problems/design-linked-list/)



#### 反转链表

题目：[反转一个单链表](https://leetcode-cn.com/problems/reverse-linked-list/)



#### 两两交换链表中的节点

题目：[给定一个链表，两两交换其中相邻的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)



#### 删除链表中倒数第n个节点

题目：[删除链表的倒数第n个节点，返回头节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

进阶：能否使用一趟扫描实现



#### 链表相交

题目：[链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点，如果两个链表没有相交，返回null。



#### 环形链表Ⅱ

题目：[环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null

说明：不允许修改给定的链表



## 

## 回溯算法

一般回溯算法都涉及递归，是一种暴力的搜索方法。for循环横向遍历，递归纵向遍历（树形结构）

### 解决的问题

**1.组合问题(没有顺序)**

[组合总和(无重复元素的整数数组)](https://leetcode-cn.com/problems/combination-sum/)

[组合总和2(需要处理掉重复的结果)](https://leetcode-cn.com/problems/combination-sum-ii/)

**2.切割问题**

[一个字符串进行切割并返回所有的组成的回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

[复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

**3.子集问题**

求一个集合的子集。

**4.排列问题(有顺序)**

与组合问题相对应

**5.棋盘问题**

n皇后问题等等，（还没遇到）

### 模板

```c++
void backtracking(参数)
{
    if(终止条件){
        收集结果;
        return;
    }
    
    for(集合元素){
        处理节点;
        递归函数;
        回溯函数;（类似于栈，将之前的中间值出栈，撤销处理结果，尝试其他的可能性）
    }
}
```



## 字符串的模式匹配

给定两个字符串S和T，**在主串S中寻找字串T的过程称为模式匹配**，**T称为模式**。如果匹配成功，则返回T在S中的位置；如果匹配失败，返回0.

### BF算法（朴素的模式匹配算法）

#### 概念

BF算法是一种**回溯**的匹配算法，其基本思想是：从主串S的第一个字符开始和模式T的第一个字符进行比较，若相等，则继续比较二者后续的字符，否则，则从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直到S或T中的所有字符比较完毕。若T中的所有字符全部比较完成，则匹配成功，否则匹配失败。

#### 代码

```c++
int BF(string a,string b)
{
    int i=0,j=0;
    while(i<a.size()&&j<b.size())
    {
        if(a[i]==b[j])
        {
            i++;
            j++;
        }
        else
        {
            i=i-j+1;//返回主串中上一次开始匹配的下一个位置
            j=0;//重新从字串的第一个位置开始匹配
        }
    }
    if(j==b.size())//若字串全部匹配完成，则匹配成功
        return i-j+1;//返回字串所在主串中的位置，不是数组下标
    else
        return -1;
}
```

#### 时间复杂度

**最好的情况：每次不成功的匹配都发生在模式T的第一个字符   O(m+n)**

**最坏的情况：每次匹配不成功都发生在模式T的最后一个字符   O(n*m)**

### KMP算法(BF算法的改进)

#### 概念

BF算法简单但效率低，一种对BF算法做了很大改进的模式匹配算法是KMP算法，其基本思想是主串不进行回溯。

**希望在某趟S[i]和T[j]匹配失败后，下标i不回溯，下标j回溯至某个位置k，使得T[k]对准S[j]继续比较。显然关键问题是如何确定k。**

#### 代码





### rabin karp算法（基于Hash的字符串匹配）

例题：[最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

