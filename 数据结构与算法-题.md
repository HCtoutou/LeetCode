## 数组

### 理论基础

数组是存放在连续内存空间中的相同类型数据的集合。

需要注意的是：

- 数组下标都是从0开始的。

- 数组内存空间的地址是连续的（二维也是连续的）

  正是因为数组在内存空间中的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。

- 数组的元素不能删除，只能覆盖



### 测试代码

```c++
void test_arr() {
    int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0]<< endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1]<< endl;
}

int main() {
    test_arr();
}
```

```c++
//测试结果
0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
//说明二维数组的地址也是连续的，每两个值之间相差4，是因为这是一个int型的数组，一个int 4字节
```



### 例题

#### 二分查找

##### 问题

给定一个n个元素的整型数组 nums 和一个目标值 target，写一个函数搜索nums中的target，如果目标值存在返回下标，否则返回-1。**（这个数组必须是有序的，否则需要先排序才能在用二分查找的算法）**

##### 思路

这种题目的前提是数组为有序数组，同时强调数组中无重复元素，因为一但有重复的元素，使用二分查找返回的下表不唯一。

写二分法，区间的定义一般分为两种，左闭右闭即 **[left,right]**,或者左闭右开即**[left,right)**.

下面我们用这两种区间的定义分别来讲解两种不同的二分写法

##### 二分法代码(数组按升序的方式排列)

```c++
//左闭右闭 [left,right]
class Solution{
  public:
    int search(vector<int>& nums,int target)
    {
        int left=0;//左指针指向第一个元素
        int right=nums.size()-1;//右指针指向最后一个元素
        while(left<=right)
        {
            int mid=left+((right-left)/2);//防止溢出，等同于(left+right)/2
            if(nums[mid]>target)
                right=mid-1;
           	else if(nums[mid]<target)
                left=mid+1;
            else
                return mid;           
        }
        return -1;//未找到
    }
};
```

```c++
//左闭右开[left,right)
class Solution{
  public:
    int search(vector<int>& nums,int target)
    {
        int left=0;//左指针指向第一个元素
        int right=nums.size()-1;//右指针指向最后一个元素
        while(left<right)//因为left=right在左闭右开的范围内无效，所以不需要等于
        {
            int mid=left+((right-left)/2);//防止溢出，等同于(left+right)/2
            if(nums[mid]>target)
                right=mid-1;
           	else if(nums[mid]<target)
                left=mid+1;
            else
                return mid;           
        }
        return -1;//未找到
    }
};
```

##### 例题

- [二分查找](https://leetcode-cn.com/problems/binary-search/)
- [搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

- [二分查找确定左右边界](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

**以“在排序数组中查找元素的第一个和最后一个位置”为例**

**题目：给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。**

**如果数组中不存在目标值 target，返回 [-1, -1]。**

**分析：寻找target在数组里的左右边界，共有如下三种情况**

1. **target在数组范围的右边或者左边（即大于数组的最大值或者小于数组的最小值），例如nums={3，4，5}，target=6，此时返回{-1，-1}；**
2. **target在数组范围中，但数组中不存在target，例如nums={3，6，7}，target=5，此时应该返回{-1，-1}；**
3. **target在数组范围中，且数组中存在target，例如nums={3，6，7}，target={6}，此时应该返回{1，1}**

**据此我们就可写出如下代码，分别找出左右边界。**

```c++
//题解
/*for循环遍历数组，k用来记录共出现几次，result用来记录出现的位置
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result;
        int k=0;
        for(int i=0;i<nums.size();i++)
        {
            if(nums[i]==target)
            {
            result.push_back(i);
            k++;
            }
        }
        if(k==0)
        return {-1,-1};
        else
        return {result[0],result[k-1]};
    }
};*/


//利用二分查找分别搜索左右边界
class Solution {
public:
    int FindLeftBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int leftborder=-2;//边界的初始值不能赋值为-1，若数组的第一个元素为目标值，则左边界为-1，有边界同理
        while(left<=right)
        {
            int mid=left+((right-left)/2);
            if(nums[mid]>=target)//不停的缩小左边界
            {
                right=mid-1;
                leftborder=right;
            }
            else
            left=mid+1;
        }
        return leftborder;
    }

    int FindRightBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        int rightborder=-2;
        while(left<=right){
        int mid=left+((right-left)/2);
        if(nums[mid]<=target)//不停的缩小右边界
        {
            left=mid+1;
            rightborder=left;
        }
        else
        right=mid-1;
        }
        return rightborder;
    }
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftborder;
        int rightborder;
        
        leftborder = FindLeftBorder(nums,target);
        rightborder = FindRightBorder(nums,target);
        
        /*左边界与右边界等于-2证明目标值不在数组范围内*/
        if(leftborder==-2)
        return {-1,-1};
        
        /*因为左边界指向最左边的目标值的前一个位置，有边界指向最右边的目标值的下一个位置，因此需要大于1不能有等于1*/
        else if((rightborder-leftborder)>1)
        return {leftborder+1,rightborder-1};
        
        /*所要查找的元素位于数组范围中但并不再数组中，这样左边界与有边界就会相邻，相减等于1*/
        /*nums = [5,7,7,8,8,10]，target = 6*/
        else
        return {-1,-1};
    }
};
```



#### 移除元素

题目：[移除元素](https://leetcode-cn.com/problems/remove-element/)

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

##### 解法

**暴力解法**

两层for循环，一个for循环遍历数组元素，第二个for循环更新数组

```c++
// 时间复杂度：O(n^2)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int size = nums.size();
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) { // 发现需要移除的元素，就将数组集体向前移动一位
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];
                }
                i--; // 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                size--; // 此时数组的大小-1
            }
        }
        return size;

    }
};
```

**双指针法**

通过一个快指针和慢指针在一个for循环下完成两个for循环的工作

```c++
// 时间复杂度：O(n)
// 空间复杂度：O(1)
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++) {
            if (val != nums[fastIndex]) {
                nums[slowIndex++] = nums[fastIndex];
            }
        }
        return slowIndex;
    }
};
```

#### 有序数组的平方

[力扣题目链接](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

**题目：给你一个按非递减顺序排序的整数数组 nums，返回每个数字的平方组成的新数组，要求也按非递减顺序排序**

##### 暴力排序：平方后排序

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        for (int i = 0; i < A.size(); i++) {
            A[i] *= A[i];
        }
        sort(A.begin(), A.end()); // 快速排序
        return A;
    }
};
```

##### 双指针法

**数组本身是有序的，只不过负数的平方可能比正数的平方大，那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。**

**此时就可以考虑双指针法了，i指向起始位置，j指向终止位置。**

**定义一个新数组result，和原数组一样大小，让k指向result数组终止位置。**

**如果A[i] * A[i] < A[j] * A[j]那么result[k--]=A[j] * A[j]**

**如果A[i] * A[i] >=A[j] * A[j]那么result[k--]=A[i] * A[i]**

```c++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

#### 长度最小的子数组

题目：[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

##### 题解

**暴力解法**

两个for循环遍历数组，不断的寻找符合条件的子序列，时间复杂度为O(n^2)

```c++
class Solutin{
    public:
    int minSubArrayLen(int s,vector<int>& nums)
    {
        int result=INT32_MAX;//最终结果
        int sum=0;
        int subLength=0;
        for(int i=0;i<nums.size();i++)
        {
            sum=0;
            for(int j=i;j<nums.size();j++)
            {
                sum=sum+nums[j];
                if(sum>=s){
                    subLength=j-i+1;//更新长度
                    result=result<subLength?result:subLength;//更新result，因为需要找的是符合条件的最短的串
                    break;//找到了以i为起点以j为终点的最短的串，退出当前循环
                }
            }
        }
    }
}
```

##### 滑动窗口

不断的调节子序列的起始位置和终止位置，从而得出我们想要的结果

**在本题中实现滑动窗口，主要确定如下三点：**

- 窗口内是什么？

  窗口就是满足其和大于等于目标值的长度最小的连续子数组。
  
- 如何移动窗口的起始位置？

  窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）

- 如何移动窗口的结束位置？

  窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，窗口的起始位置设置为数组的起始位置就可以了。

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int i=0,j=0;
        int result=INT32_MAX;
        int mid=0;
        int len;
        while(j<nums.size())
        {
            mid=mid+nums[j];
            while(mid>=target)
            {
                len=j-i+1;//计算当前的长度
                result=result<len?result:len;//更新长度，将较短的填入result
                mid=mid-nums[i++];//移动窗口的起始位置，将当前起始位置的值减掉，将起始位置向后移动一个
            }
            j++;//调整窗口的结束位置
        }
        /*for(int j=0;j<nums.size();j++)//j表示终点，
        {
        mid=mid+nums[j];
        while(mid>=target){
            len=j-i+1;
            result=result<len?result:len;
            mid=mid-nums[i];
            i++;
        }
        }*/
        return result=(result==INT32_MAX)?0:result;
    }
};
```



#### 螺旋矩阵Ⅱ

题目：[螺旋矩阵Ⅱ](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 

##### 题解

**本题在面试中出现频率较高，并且本体并不涉及算法，就是模拟过程，但却十分考察对代码的掌控能力。**

模拟顺时针画矩阵的过程：

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

```c++
class Solution{
  public:
    vector<vector<int>> generateMatrix(int n){
        vector<vector<int>> res(n,vector<int>(n,0));//定义一个二维数组
        int startx=0,starty=0;//定义每循环一个圈的起始位置
        int loop=n/2;//每个圈循环几次
        int mid=n/2;//矩阵中间的位置
        int count=1；//用来给矩阵中每一个空格赋值
        int offset=1;//每一圈循环，需要控制每一条边遍历的长度
        int i,j;
        while(loop--){
            i=startx;
            j=starty;
            
            //填充上行从左到右
            for(j=starty;j<starty+n-offset;j++)
            	res[startx][j]=count++;
            //填充右列从上到下
            for(i=startx;i<startx+n-offset;i++)
                res[i][j]=count++;
            //填充下行从右到左
            for(;j>starty;j--)
                res[i][j]=count++;
            //填充左列从下到上
            for(;i>startx;i--)
                res[i][j]=count++;
            
            startx++;
            starty++;
            
            offset+=2;
        }
        if(n%2){
            res[mid][mid]=count;
        }
        return res;
    }
};
```

```c++
class Solution{
  public:
    vector<vector<int>> generateMatrix(int n){
        vector<vector<int>> res(n,vector<int>(n,0));//定义一个二维数组
        int tot=0;
        int x=0,y=0;
        tot=res[x][y]=1;//因为第一个位置肯定是1，所以先赋值，方便后面的循环判断，防止有bug陷入死循环。
        while(tot<n*n)
        {
            //判断下一个位置是否为0，若判断当前位置是否为0会陷入死循环
            //上行从左往右，左闭右开
            while(y+1<n&&!res[x][y+1]) res[x][++y]=++tot;
            
            //右列从上往下，上闭下开
            while(x+1<n&&!res[x+1][y]) res[++x][y]=++tot;
            
            //下行从右往左，左开右闭
            while(y-1>=0&&!res[x][y-1]) res[x][--y]=++tot;
            
            //左列从下往上，上开下闭
            while(x-1>=0&&!res[x-1][y]) res[--x][y]=++tot;
            
            /*错误写法*/
            /*没有给起始位置赋初值1*/
            /*下面的写法在写完一圈后x会回到第一个位置，而这个位置已经赋值了，因此就会陷入死循环
          /*while (y < n-1 && !res[x][y]) res[x][y++] = ++tot;
			while (x < n-1 && !res[x][y]) res[x++][y] = ++tot;
			while (y > 0 && !res[x][y]) res[x][y--] = ++tot;
			while (x > 0 && !res[x][y]) res[x--][y] = ++tot;*/
        }
        return res;
    }
};
```



## 链表

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放下一个节点的指针），最后一个节点的指针域指向null。

链接的入口节点称为链表的头结点也就是head。

### 链表的类型

#### 单链表

#### 双链表

每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表既可以向前查询也可以向后查询

#### 循环链表

首位相连，循环链表可以解决约瑟夫环问题。

### 链表的存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

### 链表的实现

#### 链表的定义

##### 代码

```c++
//单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
//若不定义构造函数，c++会生成一个默认的构造函数

//通过自己定义构造函数初始化节点
ListNode* head = new ListNode(5);

//使用默认构造函数初始化节点
ListNode* head = new ListNode();
head->val = 5;
//如果不定义构造函数使用默认的构造函数的话，在初始化的时候就不能直接给变量赋值
```

#### 链表的操作

##### 删除节点



![链表-删除节点](https://img-blog.csdnimg.cn/20200806195114541.png)

D节点依然存留在内存中，如果是C++语言的话需要手动释放这块内存，其他语言例如Java，Python，有自己的内存回收机制，就不需要手动释放了。

##### 添加节点

![链表-添加节点](https://img-blog.csdnimg.cn/20200806195134331.png)

可以看出链表的增添和删除都是O(1)时间复杂度，也不会影响其他节点，但要注意，要删除第五个节点需要从头查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)

### 性能分析

数组插入慢O(n)，查找快O(1)。 适用场景：数据量固定，频繁查询，较少增删。

链表插入快O(1)，查找慢O(n)。 适用场景：数据量不固定，频繁增删，较少查询。

数组在定义时，长度是固定的，如果想改动数组的长度，就需要定义一个新的数组。

链表的长度是不固定的，并且可以动态增删，适合数据量不固定，频繁增删，较少查询的场景。

### 例题

#### 移除链表的元素

题目：[移除链表的元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

删除链表中等于给定值val的所有节点。

##### 题解

**不设置哑元删除节点**

```c++
class Solution{
  public:
    ListNode* removeElements(ListNode* head,int val){
        /*不使用哑元删除头结点属于特殊情况，需要单独考虑*/
        while(head!=nullptr&&head->val==val)
        {
            ListNode* tmp = head;
            head=head->next;
            delete tmp;
        }
        
        /*删除非头结点*/
        ListNode *cur = head;
        while(cur!=nullptr&&cur->next!=nullptr){//可能这个链表本身就是空的，因此需要判断当前节点是否为空以及当前节点的下一个节点是否为空
            if(cur->next->val==val)
            {
                ListNode* tmp = cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }
            else
                cur=cur->next;
        }
        return head;
    }
};
```

**设置哑节点**

```c++
class Solution{
  public:
    ListNode* removeElements(ListNode* head,int val){
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next=head;
        ListNode* cur = dummyHead;
        while(cur->next!=nullptr)
        {
            if(cur->next->val==val)
            {
                ListNode* tmp = cur->next;
                cur->next=cur->next->next;
                delete tmp;
            }
            else
                cur=cur->next;
        }
        return dummyHead->next;
    }
};
```



#### 设计链表

题目：[设计链表实现要求的功能](https://leetcode-cn.com/problems/design-linked-list/)

- get(index): 获取链表中第index个节点的值。如果索引无效则返回-1.
- addAtHead(val): 在链表的第一个元素之前添加一个值为val的节点。插入后，新节点将称为链表的第一个节点。
- addAtTail(val): 将值为val的节点追加到链表的最后一个元素。
- addAtIndex(index,val): 在链表中的第index个节点之前添加值为val的节点。如果index等于链表的长度，则该节点将符加到链表的末尾。如果index大于链表的长度，则不会插入节点。如果index小于0，则插在头部
- deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。

##### 题解:

使用哑元

```c++
class MyLinkedList{
  public:
    struct LinkedNode{
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val),next(nullptr){}
    };
    //初始化链表
    MyLinkedList(){
        dummyHead = new LinkedNode(0);
        size = 0;
    }
    /*获取到第index个节点的值，如果index非法返回-1，index是从0开始*/
    int get(int index){
        if(index>=size||index<0)
            return -1;
        LinkedNode* cur = dummyHead->next;
        while(index--)
            cur=cur->next;
        return cur->val;
    }
    /*在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点*/
    void addAtHead(int val){
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next=dummyHead->next;
        dummyHead->next = newNode;
        size++;
    }
    
    /*在链表最后面添加一个节点*/
    void addAtTail(int val){
        LinkedNode* cur = dummyHead;
        while(cur->next!=nullptr)//找到链表最后一个元素，返回它的指针
            cur=cur->next;
        LinkedNode* newNode = new LinkedNode(val);
        cur->next=newNode;
        size++;
    }
    
    /* 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。*/
    /* 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点*/
    /* 如果index大于链表的长度，则返回空*/
    void addAtIndex(int index,int val){
        if(index>size)
            return;
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = dummyHead;
        while(index--)
            cur=cur->next;
        newNode->next = cur->next;
        cur->next = newNode;
        size++;
    }
    
    /*删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的*/
    void deleteAtIndex(int index){
        if(index>=size||index<0)
            return;
        LinkedNode* cur = dummyHead;
        while(index--){
            cur=cur->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        size--;
    }
    private:
    int size;
    LinkedNode* dummyHead;
};
```



#### 反转链表

题目：[反转一个单链表](https://leetcode-cn.com/problems/reverse-linked-list/)

##### 题解

![206_反转链表](https://img-blog.csdnimg.cn/20210218090901207.png)

**使用两个指针**

![img](https://tva1.sinaimg.cn/large/008eGmZEly1gnrf1oboupg30gy0c44qp.gif)

首先定义一个cur指针，指向头结点，在定义一个pre指针，初始化null。

然后开始反转，首先cur->next节点用tmp指针保存一下，也就是保存一下这个节点，为什么要保存一下这个节点呢，因为接下来要改变cur->next的指向了，将cur->next指向pre，此时已经反转了第一个节点了。接下来就是循环执行。最后cur指针已经指向null，循环结束，链表也反转完毕了，此时我们return pre指针就可以了

##### 代码

```c++
/*双指针法*/
class Soultion{
  public:
    ListNode* reverseList(ListNode* head){
    	ListNode* temp;//保存cur的下一个节点
    	ListNode* cur = head;
    	ListNode* pre = nullptr;
        while(cur){
            temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};

/*递归法*/
class Solution{
  public:
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur==nullptr) return pre;
        ListNode* temp = cur->next;
        cur->next = pre;
        return reverse(cur,temp);
    }
    
    ListNode* reverseList(ListNode* head){
        return reverse(nullptr,head);
    }
};
```

**我们发现上面的递归写法和双指针写法实质上都是从前往后翻转指针指向其实还有另外一种与双指针法不同思路的递归写法：从后往前翻转指针指向**

```c++
class Solution{
    public:
    ListNode* reverseList(ListNode* head){
        if(head == nullptr) return nullptr;
        if(head->next==nullptr) return head;
        
        ListNode *last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
};
```



#### 两两交换链表中的节点

题目：[给定一个链表，两两交换其中相邻的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

##### 题解

对交换过程正常进行模拟就可以，设置虚节点，不然每次针对头结点还要单独处理；

![24.两两交换链表中的节点1](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

##### 代码

```c++
class Solution{//从需要交换值的两个节点的前一个结点开始
  public:
    ListNode* swapPairs(ListNode* head)
    {
        ListNode* dummyHead = new ListNode(0);//设置哑节点
        dummyHead->next = head;
        ListNode* cur = dummyHead;//设置指针并指向哑节点，每次交换完成后将指针移动两下
        while(cur->next!=nullptr&& cur->next->next!=nullptr)
        {
           /* ListNode* tmp = cur->next;
            ListNode* tmp! = cur->next->next->next;
            cur->next = cur->next->next;
            cur->next->next = tmp;
            cur->next->next->next = tmp1;*/
            
            ListNode* tmp = cur->next;//保存需要交换的前一个结点
            cur->next = cur->next->next;//将两个结点之前的结点指向需要交换的第二个结点
            tmp->next = cur->next->next;//将需要交换的第一个结点指向第二个结点的下一个结点
            cur->next->next = tmp;//将第二个结点的下一个结点指向第一个结点
            
            cur = cur->next->next//将指针移动两下，指针后的两个结点为需要进行交换的结点。
        }
        return dummyHead->next;
    }
};
```



#### 删除链表中倒数第n个节点

题目：[删除链表的倒数第n个节点，返回头节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

进阶：能否使用一趟扫描实现

##### 题解

- 第一种可对链表进行两次扫描，第一次扫描得出链表得长度，从而通过计算得出倒数第n个是正数第几个，从而进行第二次扫描删除结点
- 使用双指针，第一个指针先走n步，之后两个指针一块走，当第一个指针走到最后一个元素得时候，第二个指针就指向了需要删除的结点得上一个结点。从而进行删除。

##### 代码

```c++
class Solution{//两次扫描，不适用哑节点
    public:
    ListNode* removeNthFromEnd(ListNode* head,int n)
    {
        int nums=0;//记录链表共有多少个节点
        ListNode* cur = head;
        while(cur!=nullptr)
        {
            nums++;
            cur = cur->next;
        }
        ListNode* tmp = head;
        if(n==nums)//需要删除的是头结点，因头结点前面没有节点，所以需要单独处理
        {
            head = head->next;
            return head;
        }
        for(int i=0;i<nums-n-1;i++)
        {
            tmp = tmp->next;
        }
        tmp->next = tmp->next->next;
        return tmp;
    }
    
};
```

```c++
class Solution{//使用双指针，第一个指针先走n步，之后两个指针一块走，当第一个指针走到最后一个节点时，第二个指针就指向了需要删除的节点得上一个节点
  public:
    ListNode* removeNthFromEnd(ListNode* head,int n)
    {
        ListNode* dummyHead = new ListNode(-1);
        dummyHead->next = head;
        ListNode* fast = dummyHead;
        ListNode* slow = dummyHead;
        for(int i=0;i<n&&;i++)
            fast = fat->next;
        while(fast->next!=nullptr)
        {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyHead->next;
    }
};
```





#### 链表相交

题目：[链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点，如果两个链表没有相交，返回null。

##### 题解

简单来说就是求两个链表交点节点的指针。**需要注意交点不是数值相等，而是指针相等**

我们先遍历两个链表，求出两个链表的长度两个链表的长度做差得出一个值，让长的链表先移动一定的值使指向两个链表的指针在同一位置，之后一次移动两个链表的指针，直到结束，如果有指针相等，则此节点为相交的节点，否则没有相交

##### 代码

```c++
class Solution{
  ListNode* getIntersectionNode(ListNode* headA,ListNode* headB)  
  {
      int numA=0;
        int numB=0;
        int len;
        ListNode* curA = headA;
        ListNode* curB = headB;
        /*统计两个链表的长度*/
        while(curA!=nullptr)
        {
            curA = curA->next;
            numA++;
        }
        while(curB!=nullptr)
        {
            curB=curB->next;
            numB++;
        }

        curA = headA;
        curB = headB;
    /*调整指向链表的指针*/
        if(numA>numB)//a链表长
        {
        len = numA-numB;
        for(int i = 0;i<len;i++)
        curA = curA->next;
        while(curA!=nullptr)
        {
            if(curA==curB)
            return curA;
            curA=curA->next;
            curB=curB->next;
        }
        }

        else//b链表长
        {
        len = numB-numA;
        for(int i = 0;i<len;i++)
        curB = curB->next;
        while(curA!=nullptr)
        {
            if(curA==curB)
            return curA;
            curA=curA->next;
            curB=curB->next;
        }
        }
        return nullptr;
  }
};
```



#### 环形链表Ⅱ

题目：[环形链表Ⅱ](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null

说明：不允许修改给定的链表

##### 题解

1.判断是否有环

使用快慢指针法，快指针每次走两步，慢指针每次走一步，如果两个指针相遇，则证明有环

2.求出环的其实位置

假设从头节点到环形入口的节点数为x。环形入口节点到fast指针与slow指针相遇的节点的节点数为y，从相遇节点到环形入口节点的节点数为z。

![142环形链表2](https://img-blog.csdnimg.cn/20210318162938397.png)

快指针走的节点数始终是慢指针的两倍，根据这个等式可列出方程解出x的值

慢指针走的节点：x+y

快指针走的节点：x+n*(y+z)+y

2x+2y = x+n(y+z)+y

x = ny+nz-y   ----> x = (n-1)(y+z) + z  n为快指针在环中走的圈数

**该表达式表明了从相交节点绕环走n-1圈在刚好走一个z的距离和x相等，走n-1圈又回到相交节点，在走z个节点刚还到达环的入口，若让一个指针指向头结点，并和相交节点的指针一块移动，则此时它们会在环的入口相遇**

由次式可看出头结点指针与相交节点的指针同时走，当他们相交时，便是环的入口

##### 代码

```c++
class Solution{
  public:
    ListNode* detectCycle(ListNode* head){
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=nullptr&&fast->next!=nullptr)
        {
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow)
            {
                ListNode* cur = head;
                while(cur!=fast)
                {
                    fast = fast->next;
                    cur = cur->next;
                }
                return cur;
            }
        }
        return nullptr;
    }
};
```



## 哈希表

### 哈希表的理论基础

#### 概念

什么是哈希表，哈希表，英文名为Hash table，国内一些书籍翻译为散列表。**哈希表是根据关键码的值而直接访问的数据结构（直白来讲数组就是一个哈希表）**

哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素。

**一般哈希表都是用来快速判断一个元素是否出现集合里**

例如要查询一个名字是否在这所学校里，要使用枚举方法的话时间复杂度就是O(n)，但是使用哈希表的话，只需要O(1)就可以做到。我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校了。将学生姓名映射到哈希表上就涉及到了hash function，也就是哈希函数。

#### 哈希函数

![哈希表2](https://img-blog.csdnimg.cn/2021010423484818.png)

如果hashCode得到的数值大于哈希表的大小了，那就对tablesize取模。

#### 哈希碰撞

- 拉链法（分离链接法）  若发生冲突，建立链表存在同一个索引下。
- 线性探测法 发生冲突，则查找一个空位来存储

#### 常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构

- 数组
- set(集合)
- map(映射)

在C++中，set和map分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(log n) | O(log n) |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

**std::unordered_set底层实现为哈希表，std::set和std::multiset的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树错乱，所以只能删除和增加**



| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可以重复    | key不可修改  | O(log n) | O(log n) |
| std::multimap      | 红黑树   | key有序  | key可以重复      | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

### 例题

#### 有效的字母异位词

##### 题目

[给定两个字符串s和t，编写一个函数来判断t是否是s的字母异位词。](https://leetcode-cn.com/problems/valid-anagram/)（若s和t中每个字符出现的次数都相同，则称s和t互为字母异位词）

##### 题解

- 若两个字符串为异位词，则两个字符串排序后相等

  ```c++
  class Solution {
    bool isAnagram(string s,string t)
    {
        if(s.size()!=t.size())
            return false;
        sort(s.begin(),s.end());
        sort(t.begin(),t.end());
        return s==t;
    }
  };
  ```

- 使用哈希表的方法，维护一个大小为26的数组，用来记录一个字符串中字母的出线次数，在遍历第二个字符串时减去相应字母的出现次数，最后若数组中的所有值都为0，则为异位词。

  ```c++
  class Solution{
    bool isAnagram(string s,string t)
    {
        //数组本身就是一个哈希表
          int result[26]={0};//定义一个数组大小为26，来保存26个字母的出现次数
          for(int i=0;i<s.size();i++)
          {
              result[s[i]-'a']++;//s[i]-'a'就是这个字母相对于数组的相对位置
          }
          for(int j=0;j<t.size();j++)
          result[t[j]-'a']--;//遍历t字符串，若在数组中存在相同的字母则该位置的值减一。
          for(int k=0;k<26;k++)
          {
              if(result[k]!=0)//最终数组中的值都为1则证明两个是异位词
              return false;
          }
          return true;
    }
  };
  ```



#### 两个数组的交集

##### 题目

[给定两个数组，编写一个函数来求他们的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

##### 题解

这道题目主要要学会一种哈希数据结构：unordered_set,这个数据结构可以解决很多类似的问题。

注意题目特别说明**输出结果中的每个元素一定是唯一的，也就是说输出的结果是去重的。，同时可以不考虑输出结果的顺序**，若使用数组来做哈希的题目，是因为题目限制数值的大小，即知道了数组的大小。**如果哈希值比较少，特别分散，跨度非常大，使用数组就造成空间的极大浪费。**此时就要使用另外一种结构体了，set。

##### 代码

**使用set**

```c++
class Solution {
  publci:
    vector<int> intersection(vector<int>& nums1,vector<int>& nums2)
    {
        unordered_set<int> result_set;//存放结果
        unordered_set<int> nums_set(nums1.begin(),nums1.end());
        for(int i=0;i<nums2.size();i++)
        {
            //发现nums2的元素在nums_set里出现过
            if(nums_set.find(nums2[i])!=nums_set.end());
            result_set.insert(nums2[i]);
        }
        return vector<int>(result_set.begin(),result_set.end());
    }
};
```

**双指针法**

```c++
class Solution {
  public:
    vector<int> intersection(vector<int>& nums1,vector<int>& nums2)
    {
        sort(nums1.begin(),nums1.end());
        sort(nums2.begin(),nums2.end());
        vector<int> result;//存放结果
        int i=0,j=0;
        while(i<nums1.size()&&j<nums2.size())
        {
            int num1 = nums1[i], num2 = nums2[j];
            if(num1==num2)
            {
                if(!result.size()||num1 != result.back())//保证元素的唯一性
                {
                //tmp = nums1[i];
                result.push_back(num1);
                }
                    i++;
                    j++;
            }
            else if(num1<num2)//将值小的指针向后移动，大的不动
            i++;
            else
            j++;
        }
        return result;
    }
};
```

##### 拓展

直接使用set不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的，不要小瞧这个耗时，在数据量大的情况下，差距是很明显的。

#### 快乐数

##### 题目

[编写一个算法判断一个数n是不是快乐数](https://leetcode-cn.com/problems/happy-number/)

快乐数定义为：

- 对于一个整数，每一次将该数替换为它每个位置上的数字的平方和
- 然后重复这个过程直到这个数变为1，也可能是无限循环但始终变不到1.
- 如果可以变为1，那么这个数就是快乐数。

##### 题解

不断进行加法运算，会出现以下三种可能：

- 最终得到1
- 最终会进入一个循环
- 值会越来越大，最后接近无穷大

第三种情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到1呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。

| Digits | Largest       | Next |
| ------ | ------------- | ---- |
| 1      | 9             | 81   |
| 2      | 99            | 162  |
| 3      | 999           | 243  |
| 4      | 9999          | 324  |
| 13     | 9999999999999 | 1053 |

对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 2432以下的循环内，要么跌到 1。4位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。但它不会无限期地进行下去，所以我们排除第三种选择。

即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。

##### 代码

**使用set判断是否进入循环**

```c++
class Solution{
  public:
    //取数值各个位上的单数和
    int getSum(int n)
    {
        int sum = 0;
        while(n){
            sum = sum + (n%10)*(n%10);
            n=n/10;
        }
        return sum;
    }
    
    bool isHappy(int n){
        unordered_set<int> set;
        while(1)
        {
            int sum = getSum(n);
            if(sum == 1)
                return true;
            if(set.find(sum)!=set.end())
                return false;
            else
                set.insert(sum);
            n=sum;
        }
    }
};
```

**使用双指针判断是否进入循环**

```c++
class Solution {
    public:
    int getSum(int n)
    {
        int sum = 0;
        while(n!=0)
        {
            sum = sum + (n%10)*(n%10);
            n = n/10;
        }
        return sum;
    }

    bool isHappy(int n){
        int slow = n;
        int fast = n;

        while(1)
        {
            slow = getSum(slow);
            fast = getSum(fast);
            fast = getSum(fast);
            if(slow == fast)
            break;
        }
        return fast == 1;
    }
};
```

#### 四数相加Ⅱ

##### 题目

[给定四个包含整数的数组列表A,B,C,D计算有多少个元组(i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。](https://leetcode-cn.com/problems/4sum-ii/submissions/)

##### 题解

- 首先定义一个unordered_map，key放a和b两数之和，value放a和b两数之和出现的次数
- 遍历A和B数组，统计两个数组元素之和，和出现的次数，放到map中
- 定义int变量count，用来统计a+b+c+d=0出现的次数
- 在遍历C和D数组找到找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
- 最后返回统计值 count 就可以了

##### 代码

```c++
class Solution {
    public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4)
    {
            int n=nums1.size();
            unordered_map<int,int> mapA;//用来保存前两个数组的所有和
            for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
            mapA[nums1[i]+nums2[j]]++;

            int result = 0;//保存最终的结果
            for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
            {
                int target = 0 - (nums3[i]+nums4[j]);
                if(mapA.find(target)!=mapA.end())//判断在哈希表中是否存在符合条件的值
                result = result + mapA[target];//将value值加起来
            }
            return result;
    }
};
```

#### 赎金信

##### 题目

[给定两个字符串：ransomNote和magazine，判断ransomNote能不能由magazine里面的字符构成。如果可以返回true，否则返回false。](https://leetcode-cn.com/problems/ransom-note/)

##### 题解

可以采用哈希表，可以先将magazine的单词存进哈希表，然后在用遍历randomNote判断哈希表里是否有组成它的单词，此处因为涉及英文字母，且全部为小写，所以可以采用数组来构成哈希表，效率更高。

##### 代码

```c++
class Solution {
   public:
    bool canConstruct(string ransomNote,string magazine)
    {
        int arr[26];
        for(int i=0;i<magazine.size();i++)
            arr[magazine[i]-'a']++;
        
        for(int i=0;i<ransomNote;i++)
        {
            arr[ransomNote[i]-'a']--;
            if(arr[ransomNote[i]-'a']<0)
                return false;
        }
        return true;
    }
}；
```



## 字符串

### 例题

#### 反转字符串

##### 题目

[编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组s的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组，使用O(1)的额外空间来解决这以问题。](https://leetcode-cn.com/problems/reverse-string/)

##### 题解

使用双指针直接交换即可

##### 代码

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        int i=0;
        int j=s.size()-1;
        while(i<j)
        {
            char c;
            c=s[i];
            s[i]=s[j];
            s[j]=c;
            i++;
            j--;
        }
    }
};
```



#### 反转字符串Ⅱ

##### 题目

[给定一个字符串s和一个整数k，从字符串开头开始算起，每计数至2k个字符就反转这2k字符串中的前k个字符。](https://leetcode-cn.com/problems/reverse-string-ii/)

- 如果剩余字符数少于k个，则将剩余字符全部反转。
- 如果剩余字符小于2k但大于等于k个，则反转前k个字符。其余字符保持原样。

##### 题解

对题目要求进行模拟，在遍历字符串的过程中，只要让i=i+2*k，每次移动2k就可以了，然后判断所处的区间进行反转

##### 代码

```c++
class Solution {
public:
    void reverse(string& s,int start,int end)
    {
        while(start<end)
        {
            swap(s[start],s[end]);
            start++;
            end--;
        }
    }
    string reverseStr(string s, int k) {
        int n = s.size();
        for(int i=0;i<n;i=i+2*k)
        {
            if(n-i-1<k)//剩余字符小于k则全部反转
            {
                reverse(s,i,n-1);//交换剩余的元素
            }
            else if(n-i-1>=k)//剩余字符大于k则反转前k个，小于2k可以和普通的放在一块处理
            {
            reverse(s,i,i+k-1);//交换前k个元素
            continue;
            }
        }
        return s;
    }
};
```

#### 替换空格

##### 题目

[请实现一个函数，把字符串s中的每个空格替换成“%20”.](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

##### 题解

先将原来字符转的大小扩充为添加后的大小，因为每次需要在一个空格处添加三个字符。这一步需要遍历字符串统计空格个数。之后从后向前遍历，在遍历的过程中字符串整体后移，当遇到空格时就进行替换。

**如果从前向后填充就是O(n^2)的时间复杂度了，因为每次添加元素后都需要将后面的元素后移**

**其实很多数组填充类问题，都可以先预先给数组扩容后，从后向前进行操作**

**优点**

- 不用申请新数组
- 从后向前填，避免了从前向后填充元素时，每次都需要将后面的元素后移。

##### 代码

```c++
class Solution {
public:
    string replaceSpace(string s) {
        int count = 0;
        int n = s.size();
        for(int i=0;i<s.size();i++)
        {
            if(s[i]==' ')
            count++;
        }
		//resize(n)扩充为n个大小
        s.resize(s.size()+count*2);//扩充s的大小，能够放下相应的%20
        int i = n-1;
        int j = s.size()-1;
        while(i>=0)
        {
            if(s[i]!=' ')
            {
                s[j--]=s[i--];
            }
            else
            {
                s[j--]='0';
                s[j--]='2';
                s[j--]='%';
                i--;
            }
        }
        return s;
    }
};
```

#### 反转字符串里的单词

##### 题目

[给你一个字符串s，逐个翻转字符串中的所有单词。](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

说明：

- 输入字符串s可以在前面，后面或者单词间包含多余的空格。
- 翻转后单词间应当仅用一个空格分隔
- 翻转后的字符串中不应包含额外的空格。

实例：

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

##### 题解

这道题综合考察了字符串的多种操作，基本思路为先将整个字符串翻转，之后在将每个单词单独翻转，这样就可以将单词翻转过来了。因为整个字符串中可能含有多余的空格，因此还需要对多余的空格进行处理。

- 移除多余空格
- 将整个字符串翻转
- 将每个单词翻转

在删除多余空格时，可以使用双指针方法，而不用erase方法，如果使用erase时间复杂度会变成O(log n^2),而双指针+resize函数时间复杂度为O(log n).

```c++
//使用erase删除多余空格
void removeExtraSpaces(string& s) {
    for (int i = s.size() - 1; i > 0; i--) {
        if (s[i] == s[i - 1] && s[i] == ' ') {
            s.erase(s.begin() + i);//for循环嵌套erase函数，erase的时间复杂度为O(n)
        }
    }
    // 删除字符串最后面的空格
    if (s.size() > 0 && s[s.size() - 1] == ' ') {
        s.erase(s.begin() + s.size() - 1);
    }
    // 删除字符串最前面的空格
    if (s.size() > 0 && s[0] == ' ') {
        s.erase(s.begin());
    }
}
```



##### 代码

```c++
class Solution {
public:
    void reverse(string& s,int begin,int end)//翻转字符串
    {
        while(begin<end)
        swap(s[begin++],s[end--]);
    }

    string reverseWords(string s) {
        int slow = 0;
        int fast = 0;
        int n=s.size();
        while(s[fast]==' ')
        fast++;//调整fast位置，使得fast开始指向第一个不为空格的字母，排除首部空格
        //printf("%d\n",fast);
        while(fast<n)
        {
            if(s[fast]!=' ')
            {
                s[slow++]=s[fast++];
            }
            else
                if(fast+1<n&&s[fast+1]!=' ')
                s[slow++]=s[fast++];
                else
                fast++;
        }
        //printf("%d",slow);//slow为去掉多余空格后字符串的大小
        s.resize(slow);
        reverse(s,0,slow-1);//整体翻转字符串

        //再将每个单词翻转，即可完成题目要求
        int begin=0;
        int end=0;
        while(end<slow)
        {
            //end的下一个为空格或者end为字符串的最后一个字符，则将begin与end之间的字符翻转
            if(s[end+1]==' '||end+1==slow)//end的下一个为空格或者end为
            {
                reverse(s,begin,end);
                begin = end+2;
                end=begin;
            }
            else
            end++;
        }
        return s;
    }
};
```

#### 左旋转字符串

##### 题目

[字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

##### 题解

可定义一个新的字符串将其大小设置为与原本字符串一样大，之后按照顺序将字符放进去即可。

第二种方法可**不申请额外的内存空间**，通过对字符串进行局部反转+整体翻转，可达到左旋转的目的。具体步骤为：

- 反转区间为前n的子串
- 反转区间为n到末尾的子串
- 反转整个字符串

```c++
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin() + n);
        reverse(s.begin() + n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```

#### 实现strStr（）函数

##### 题目

[给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。](https://leetcode-cn.com/problems/implement-strstr/)

##### 题解

此题为字符串匹配问题，可使用BF算法（暴力匹配）和KMP算法

- BF算法（暴力匹配）

  伪代码：

  1.在串S和串T中设置比较的起始下标i和j；

  2.重复下述操作，直到S或T的所有字符均比较完毕。

  ​	2.1 如果S[i]等于T[j],继续比较S和T的下一对字符；

  ​	2.2 否则将下标i和j回溯，准备下一趟比较。

  3.如果T中所有字符均比较完，则匹配成功，返回匹配的开始位置；否则匹配失败，返回0；

- KMP算法

- 

##### 代码

```c++
//BF算法  时间复杂度：O(n^2)
class Solution{
  public:
    int strStr(string haystack, string needle) {
        if(needle.size()==0)
        return 0;
        int i=0,j=0;
        while(i<haystack.size()&&j<needle.size())
        {
            if(haystack[i]==needle[j])
            {
                i++;
                j++;
            }
            else
            {
                i = i-j+1;
                j = 0;
            }
        }
        if(j==needle.size())
        return i-j;
        else
        return -1;
    }
};
```

#### 重复的字符串

##### 题目

[给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。](https://leetcode-cn.com/problems/repeated-substring-pattern/)

##### 题解



## 双指针

### 四数之和

#### 题目

给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）

#### 题解

使用排序加双指针代替暴力四层循环，**可将时间复杂度从O(log n^4)降到O(log n^3)**

有一些细节需要注意，不要判断nums[i]>target就返回了，因为target是任意值，负数是越加越小的。

#### 代码

```c++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        vector<vector<int>> result;
        int length = nums.size();
        if(nums.size()<4)
        return {};
        for(int i = 0;i<nums.size()-3;i++)
        {
            //if(nums[i]>0)//若nums[i]>0,则后面的数全部大于0，不可能何等于0
           // return result;
            //if(nums[i]>target)
            //return result;
            if(i>0&&nums[i-1]==nums[i])//对i指向的元素去重
            continue;
            if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {//进行剪枝
                break;
            }
            if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {
                continue;
            }
        for(int j = i+1;j<nums.size()-2;j++)
        {

            int left = j+1;
            int right = nums.size()-1;
            //if(nums[i]+nums[j]>target)
            //return result;

            if(j>i+1&&nums[j-1]==nums[j])//对j指向的元素去重
            continue;
            if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {//进行剪枝
                    break;
                }
                if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {
                    continue;
                }
            while(left<right)//调整双指针的位置
            {
                //if(nums[i]+nums[j]+nums[left]+nums[right]==target)//这种写法会溢出
                if(nums[i]+nums[j]==target-(nums[left]+nums[right]))
                {
                    result.push_back({nums[i],nums[j],nums[left],nums[right]});
                    while(right>left&&nums[left+1]==nums[left])
                    left++;
                    left++;
                    while(right>left&&nums[right-1]==nums[right])
                    right--;
                    right--;
                }
                else if(nums[i]+nums[j]>target-(nums[left]+nums[right]))
                right--;
                else
                left++;
            }
        }
        }
        return result;
    }
};
```



## 栈与队列

### 栈与队列理论基础

#### 原理

栈为后进先出，队列为先进先出如图所示

![栈与队列理论1](https://img-blog.csdnimg.cn/20210104235346563.png)

这里有四个关于栈的问题，思考一下。以下是以C++为例

**1.C++中stack是容器吗？**

**2.我们使用的stack是属于那个版本的STL？**

**3.我们使用的STL中stack是如何实现的？**

**4.stack提供迭代器来遍历stack空间吗？**

首先需要知道栈和队列是STL（C++标准库）里面的两个数据结构。

C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。那么来介绍以下，三个最为普遍的STL版本：

1.HP STL其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL时C++的第一个实现版本，而且开放源代码。

2.P.J Plauger STL由P.J Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。

3.SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。

接下来介绍的栈和队列也是SGI STL里面的数据结构，知道了使用结构，知道了使用版本，才知道对应的底层实现。

**栈，先进后出，如图所示：**

![栈与队列理论2](https://img-blog.csdnimg.cn/20210104235434905.png)

**栈提供push和pop等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器（iterator）。不像是set或者map提供迭代器来遍历元素**

**栈是以底层容器完成其所有的工作，对外提供统一接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。

从下图可以看出，栈的内部结构。栈的底层实现可以是vector，deque，list都是可以的，主要就是数组和链表的底层实现。

![栈与队列理论3](https://img-blog.csdnimg.cn/20210104235459376.png)

我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。

deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。

队列的请款与栈类似

### 例题

#### 用栈实现队列

##### 题目

[使用栈实现队列的下列操作：](https://leetcode-cn.com/problems/implement-queue-using-stacks/comments/)

- push（x）--将一个元素放入队列的尾部
- pop（x）--从队列首部移除元素。
- peek（）--返回队列首部的元素。
- empty（）--返回队列是否为空。

##### 题解

![232.用栈实现队列版本2](https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

##### 代码

```c++
class MyQueue {
public:
    stack<int> In;
    stack<int> Out;
    MyQueue() {//构造函数

    }
    
    void push(int x) {//入队
    In.push(x);
    }
    
    int pop() {//出队
    if(!Out.empty())
    {
        int result = Out.top();
        Out.pop();
        return result;
    }
    else
    {
        while(!In.empty())
        {
            Out.push(In.top());
            In.pop();
        }
        int result = Out.top();
        Out.pop();
        return result;
    }
    }
    
    int peek() {//返回队首元素
    int res=this->pop();
    Out.push(res);
    return res;
    }
    
    bool empty() {//判断是否为空
    return In.empty()&&Out.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

#### 有效的括号

##### 题目

[给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效](https://leetcode-cn.com/problems/valid-parentheses/)

##### 题解

括号匹配是使用栈解决的经典问题。

由于栈的结构的特殊性，非常适合做对称匹配类的题目。

##### 代码

```c++
class Solution {
public:
    bool isValid(string s) {
        stack<int> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false
            // 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true
        return st.empty();
    }
};
```

#### 删除字符串中的所有相邻重复项

##### 题目

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

示例：

```
输入："abbaca"
输出："ca"
```

##### 题解

使用栈，可以把字符串顺序放到一个栈中，然后如果相同的话，就弹出栈，这样最后栈里剩下的元素都是相邻不相同的元素了。

![1047.删除字符串中的所有相邻重复项](https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif)

##### 代码

```c++
//使用栈
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> str;
        for(int i=0;i<s.size();i++)
        {
            if(str.empty()||s[i]!=str.top())
            str.push(s[i]);
            else
            {
                str.pop();
            }
        }

        string result="";
        while(!str.empty())
        {
            //result+=str.top();
            result = result + str.top();
            str.pop();
        }
        reverse(result.begin(),result.end());
        return result;
    }
};
```



## 回溯算法

一般回溯算法都涉及递归，是一种暴力的搜索方法。for循环横向遍历，递归纵向遍历（树形结构）

### 解决的问题

**1.组合问题(没有顺序)**

[组合总和(无重复元素的整数数组)](https://leetcode-cn.com/problems/combination-sum/)

[组合总和2(需要处理掉重复的结果)](https://leetcode-cn.com/problems/combination-sum-ii/)

**2.切割问题**

[一个字符串进行切割并返回所有的组成的回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

[复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

**3.子集问题**

求一个集合的子集。

**4.排列问题(有顺序)**

与组合问题相对应

**5.棋盘问题**

n皇后问题等等，（还没遇到）

### 模板

```c++
void backtracking(参数)
{
    if(终止条件){
        收集结果;
        return;
    }
    
    for(集合元素){
        处理节点;
        递归函数;
        回溯函数;（类似于栈，将之前的中间值出栈，撤销处理结果，尝试其他的可能性）
    }
}
```



## 字符串的模式匹配

给定两个字符串S和T，**在主串S中寻找字串T的过程称为模式匹配**，**T称为模式**。如果匹配成功，则返回T在S中的位置；如果匹配失败，返回0.

### BF算法（朴素的模式匹配算法）

#### 概念

BF算法是一种**回溯**的匹配算法，其基本思想是：从主串S的第一个字符开始和模式T的第一个字符进行比较，若相等，则继续比较二者后续的字符，否则，则从主串S的第二个字符开始和模式T的第一个字符进行比较，重复上述过程，直到S或T中的所有字符比较完毕。若T中的所有字符全部比较完成，则匹配成功，否则匹配失败。

#### 代码

```c++
int BF(string a,string b)
{
    int i=0,j=0;
    while(i<a.size()&&j<b.size())
    {
        if(a[i]==b[j])
        {
            i++;
            j++;
        }
        else
        {
            i=i-j+1;//返回主串中上一次开始匹配的下一个位置
            j=0;//重新从字串的第一个位置开始匹配
        }
    }
    if(j==b.size())//若字串全部匹配完成，则匹配成功
        return i-j+1;//返回字串所在主串中的位置，不是数组下标
    else
        return -1;
}
```

#### 时间复杂度

**最好的情况：每次不成功的匹配都发生在模式T的第一个字符   O(m+n)**

**最坏的情况：每次匹配不成功都发生在模式T的最后一个字符   O(n*m)**

### KMP算法(BF算法的改进)

#### 概念

BF算法简单但效率低，一种对BF算法做了很大改进的模式匹配算法是KMP算法，其基本思想是主串不进行回溯。

**希望在某趟S[i]和T[j]匹配失败后，下标i不回溯，下标j回溯至某个位置k，使得T[k]对准S[j]继续比较。显然关键问题是如何确定k。**

#### 代码





### rabin karp算法（基于Hash的字符串匹配）

例题：[最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

